// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.1.3 (swiftlang-1100.0.282.1 clang-1100.0.33.15)
// swift-module-flags: -target armv7-apple-ios10.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -Onone -module-name Janus
import AuthenticationServices
import FacebookCore
import FacebookLogin
import Foundation
import GoogleSignIn
@_exported import Janus
import Security
import Swift
import SwiftyJSON
import TekCoreNetwork
import TekCoreService
import UIKit
public enum AuthError : Swift.Error, Foundation.LocalizedError {
  case notRegisteredLoginMethodYet
  case notRequestedOTPYet
  case missingRefreshToken
  case missingAccessToken
  case missingLoginType
  case requestServerFailed(message: Swift.String?)
  case missingAuthenticatorToken(type: LoginType)
  case requestAuthenticatorFailed(message: Swift.String?)
  case stillWorking
  public var localizedDescription: Swift.String {
    get
  }
  public var errorDescription: Swift.String? {
    get
  }
}
public enum LoginType : Swift.String {
  case facebook
  case google
  case apple
  case phone
  case userPassword
  public static func initialize(type: Swift.String?) -> LoginType?
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
public class Janus {
  public static var shared: Janus
  public static var configName: Swift.String
  public func initialize(config: [Swift.String : Any], for application: UIKit.UIApplication, launchOptions: [UIKit.UIApplication.LaunchOptionsKey : Any]?)
  public func initialize(config: JanusConfig, for application: UIKit.UIApplication, launchOptions: [UIKit.UIApplication.LaunchOptionsKey : Any]?)
  public func application(_ app: UIKit.UIApplication, open url: Foundation.URL, options: [UIKit.UIApplication.OpenURLOptionsKey : Any] = [:]) -> Swift.Bool
  @objc deinit
}
public protocol AuthLoginDelegate : AnyObject {
  func loginSuccess(accessToken: Swift.String, refreshToken: Swift.String)
  func loginFail(error: AuthError?)
}
public protocol IAuthCredential {
  var accessToken: Swift.String? { get }
  var refreshToken: Swift.String? { get }
  var tokenExpiredSec: Swift.Int { get }
  var tokenType: TokenType? { get }
  var data: Foundation.Data? { get }
}
public protocol AuthLoginMethod {
  func register()
}
public struct GoogleLoginMethod : AuthLoginMethod {
  public var clientId: Swift.String
  public init(clientId: Swift.String)
  public func register()
}
public class PhoneAuthProvider {
  public static var shared: PhoneAuthProvider
  public func requestOTP(phone: Swift.String, completion: @escaping (Swift.Bool, Swift.Error?) -> Swift.Void)
  public func createPasswordlessLogin(pin: Swift.String, delegate: AuthLoginDelegate?) -> PasswordlessLogin?
  @objc deinit
}
public enum KeychainSwiftAccessOptions {
  case accessibleWhenUnlocked
  case accessibleWhenUnlockedThisDeviceOnly
  case accessibleAfterFirstUnlock
  case accessibleAfterFirstUnlockThisDeviceOnly
  case accessibleWhenPasscodeSetThisDeviceOnly
  public static func == (a: KeychainSwiftAccessOptions, b: KeychainSwiftAccessOptions) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public class FacebookLogin {
  weak public var delegate: AuthLoginDelegate?
  public var type: LoginType {
    get
  }
  public init(presentViewController: UIKit.UIViewController, delegate: AuthLoginDelegate?)
  public func execute()
  @objc deinit
}
public protocol AuthLogin : AnyObject {
  var delegate: AuthLoginDelegate? { get set }
  var type: LoginType { get }
  func execute()
}
public class GoogleLogin {
  weak public var delegate: AuthLoginDelegate?
  public var type: LoginType {
    get
  }
  public init(presentViewController: UIKit.UIViewController, delegate: AuthLoginDelegate?)
  public func execute()
  @objc deinit
}
public struct PasswordlessLoginMethod : AuthLoginMethod {
  public init(passwordlessServiceUrl url: Foundation.URL)
  public func register()
}
public struct JanusConfig {
  public var oauthUrl: Swift.String
  public var identityUrl: Swift.String
  public var clientId: Swift.String
  public var scopes: Swift.String
  public var googleAppId: Swift.String?
  public var googleAppSecret: Swift.String?
  public var facebookAppId: Swift.String?
  public var appleBundleId: Swift.String?
  public init(oauthUrl: Swift.String, identityUrl: Swift.String, clientId: Swift.String, scopes: Swift.String, googleAppId: Swift.String?, googleAppSecret: Swift.String?, facebookAppId: Swift.String?, appleBundleId: Swift.String?)
}
@available(iOS 13.0, *)
public class AppleLogin {
  weak public var delegate: AuthLoginDelegate?
  public var type: LoginType {
    get
  }
  public init(presentViewController: AuthenticationServices.ASAuthorizationControllerPresentationContextProviding, delegate: AuthLoginDelegate?)
  public func execute()
  @objc deinit
}
public class AuthLoginManager {
  public static var shared: AuthLoginManager
  public func login(_ login: AuthLogin)
  public func logout()
  @objc deinit
}
public struct KeychainSwiftConstants {
  public static var accessGroup: Swift.String {
    get
  }
  public static var accessible: Swift.String {
    get
  }
  public static var attrAccount: Swift.String {
    get
  }
  public static var attrSynchronizable: Swift.String {
    get
  }
  public static var klass: Swift.String {
    get
  }
  public static var matchLimit: Swift.String {
    get
  }
  public static var returnData: Swift.String {
    get
  }
  public static var valueData: Swift.String {
    get
  }
  public static var returnReference: Swift.String {
    get
  }
  public static var returnAttributes: Swift.String {
    get
  }
  public static var secMatchLimitAll: Swift.String {
    get
  }
}
open class KeychainSwift {
  open var lastResultCode: Darwin.OSStatus
  open var accessGroup: Swift.String?
  open var synchronizable: Swift.Bool
  public init()
  public init(keyPrefix: Swift.String)
  @discardableResult
  open func set(_ value: Swift.String, forKey key: Swift.String, withAccess access: KeychainSwiftAccessOptions? = nil) -> Swift.Bool
  @discardableResult
  open func set(_ value: Foundation.Data, forKey key: Swift.String, withAccess access: KeychainSwiftAccessOptions? = nil) -> Swift.Bool
  @discardableResult
  open func set(_ value: Swift.Bool, forKey key: Swift.String, withAccess access: KeychainSwiftAccessOptions? = nil) -> Swift.Bool
  open func get(_ key: Swift.String) -> Swift.String?
  open func getData(_ key: Swift.String, asReference: Swift.Bool = false) -> Foundation.Data?
  open func getBool(_ key: Swift.String) -> Swift.Bool?
  @discardableResult
  open func delete(_ key: Swift.String) -> Swift.Bool
  public var allKeys: [Swift.String] {
    get
  }
  @discardableResult
  open func clear() -> Swift.Bool
  @objc deinit
}
public class PasswordlessLogin : AuthLogin {
  weak public var delegate: AuthLoginDelegate?
  public var type: LoginType {
    get
  }
  public init(phone: Swift.String, pin: Swift.String, delegate: AuthLoginDelegate?)
  public func execute()
  @objc deinit
}
public enum IdentityError : Swift.Int, Swift.Error {
  case invalidPhone
  case invalidEmail
  case phoneHasUsed
  case emailHasUsed
  case invalidCode
  case invalidAuth
  case other
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
public typealias OAuthLoginHandler = (Swift.Bool, AuthError?) -> ()
public typealias ExchangeTokenHandler = (Swift.Bool, Swift.String?, AuthError?) -> ()
public enum TokenType {
  case bearer
  public static func == (a: TokenType, b: TokenType) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public protocol AuthManagerProtocol {
  var credential: IAuthCredential? { get }
  var isLoggedIn: Swift.Bool { get }
  var authorizationToken: Swift.String? { get }
  func prepareNewSession(completion: @escaping OAuthLoginHandler)
  func refreshSession(completion: @escaping OAuthLoginHandler)
  func exchangeToken(audience: Swift.String, completion: @escaping ExchangeTokenHandler)
}
public class AuthManager : AuthManagerProtocol {
  public static var shared: AuthManager
  public static var expiredTimeSecDefault: Swift.Int
  public var authorizationToken: Swift.String? {
    get
  }
  public var isLoggedIn: Swift.Bool {
    get
  }
  public var credential: IAuthCredential?
  public init()
  @objc deinit
}
extension AuthManager {
  public func prepareNewSession(completion: @escaping OAuthLoginHandler)
  public func refreshSession(completion: @escaping OAuthLoginHandler)
  public func exchangeToken(audience: Swift.String, completion: @escaping ExchangeTokenHandler)
}
public struct AppleLoginMethod : AuthLoginMethod {
  public var bundleId: Swift.String
  public init(bundleId: Swift.String)
  public func register()
}
public class UserPasswordLogin : AuthLogin {
  weak public var delegate: AuthLoginDelegate?
  public var type: LoginType {
    get
  }
  public init(user: Swift.String, password: Swift.String, delegate: AuthLoginDelegate?)
  public func execute()
  @objc deinit
}
public struct FacebookLoginMethod : AuthLoginMethod {
  public var appId: Swift.String
  public init(appId: Swift.String)
  public func register()
}
extension FacebookLogin : AuthLogin {}
extension GoogleLogin : AuthLogin {}
@available(iOS 13.0, *)
extension AppleLogin : AuthLogin {}
